# Discussion about spec #

    Loops and 'putin' keyword
        I don't really understand the concept.
        Could you provide me with some explanation and possibly one or more
        use cases?
        
        Rune:
            PHP being mostly a procedural language you constantly have to deal 
            with a lot of side effects which clutters the code and makes you 
            angry. I think we should definitely address anonomous functions as 
            well at some point but we should also optimize looping over arrays 
            and collecting data which is what "putin" tries to do. Consider this 
            very normal pattern in PHP:
                <?php
                function some_func($rows) {
                    # Could also be an array or an int.
                    $html = '<h1>Page title</h1>'; 
                    foreach ($rows as $row) {
                        $html .= "<h2>$row[title]</h2>";
                    }
                    return $html;
                ?>
                
                In Snow this could be:
                @array rows
                fn some_func
                    # Loop through rows and return the content of the "html" 
                    # variable when we are done. The "html" is initialized to 
                    # "<h1>Page title</h1>".
                    return for row in rows putin html='<h1>Page title</h1>'
                        # Inside a loop ".=" collects into the variable mentioned
                        # just after the "putin" keyword.
                        .= "<h2>%row['title']</h2>"
                    And LOC count has gone from 6 to 3.
                
                In snow.snow r2 I also suggested:
                    return for row in rows putin ''
                but then we would need to use "Automatic variable naming" as you
                call it and we should minimize that. Deleted from snow.snow.
                
                Does this clarify and what do you think?
                
        Dennis:
            Yeah, it looks great, I think I like it!
                
            
    Method chaining
        What exactly is the difference between '.' and '->'
        Is it correct to state that:
            * '.' operates on objects. example:
                ftp = FTP("host")
                ftp.login("user" "pass")
            * '->' operates on native types. example:
                ["a" "b" 3: "c"]->print_r
        This is not what I define as method chaining. [1]
        It looks more like go's receiver methods. [2]
        But this is what I understand from the spec.
        What's your take on this?

        Rune:
            You you are absolutely right "method chaining" is a completely bad 
            name for it because "everything is an object" does not apply to PHP 
            which is more like "everything is a ZVAL - use a function to 
            manipulate it". Since I think Snow should be a mostly dynamically 
            typed language there is not so much we can do to change that. What I
            basically means with the "->" keyword is that it is a reverse 
            function call where the value passed to function comes before the 
            function name not after. Examples:
                Snow: 5->foo
                PHP: foo(5);
                Snow: somefunc()->foo->bar
                PHP: bar(foo(somefunc())));
                Snow: "i am white"->strtoupper
                PHP: strtoupper("i am white");
            
            Do you like it and what should we call it?
            
        Dennis:
            I don't really see an added value here, but it just looks _real_
            nice! And it's just syntactic sugar, since print_r([]) and
            []->print_r are exacty the same.
            We must really think this through though. Given the print_r()
            function, it accepts an optional 2nd parameter 'print', how do we 
            cope with that? Will this: '[]->print_r(true)' be acceptable?
            Another thing: I would love to have something like
            'my_string'->replace('my' 'your')
            But i'm not sure we should provide that kind of aliases though.
            
            About naming, don't know, somehow i like the 'receiver' as they
            call it in go, see [2]. But don't know if it's descriptive enough.

    Use of quotation
        Will PHP's default quotation rules be applied? I think we should.
        foo = ^("bar" 'baz' "%bar" '%baz')
        Gets translated to:
        <?php $foo = "bar" . 'baz' . "$bar" . '$baz'; ?>
        I think that looks fair.
        
        Rune:
            I concur!
        
    Escaping
        Default backslash escape?
        
        Rune:
            Yes.
        
    HAML
        Hadn't heard of it before, but it looks nice indeed.
        But doesn't it impose problems with the %-notation? Or is that the 
        reason you put a '$' before the variable's name?
        
        Rune:
            No the "$" is a mistake. I consider the HAML block a double quoted
            string thats why I use the "%". Indentation is used to decide where
            it ends, i.e. "next line with the same or less indentation as the
            beginning line". It could do with some more documentation - will try
            to write that. Is probably rather complicated to code.
        
        Dennis:    
            I think I like it, but I think it's more a 'nice to have', and
            therefore we should consider it only after we have some working
            implementation of an interpreter/compiler.
            The reason is that snow is a little more 'advanced' than php and
            inline html is/should be a lot less common than in 90% of the php
            code you see out there.
            Maybe we can provide a built-in package that works with haml-style
            templates?
    
    Compatible with all existing PHP code
        Could you define this more clearly?
        Does it mean the snow compiler creates code compatible with PHP 3 for
        example? I don't think it should.
        
        Rune: Lol no no. I just mean that we should be able to call functions,
        methods and constants not complying with the naming conventions of Snow
        so we are compatible with existing non-snow PHP code.
        
        Dennis:
            *Pfew*. ;)
            We should decide on a target version though. I'd say 5.x.
            Absolutely drop 4.x, but don't depend on 5.2 features or something.
        
    Can compile existing code to snow
        Though this would be a nice feature, is it worth the hassle?
        Is the benefit large enough to justify amount of work?
        
        Rune:
            Well it is a _lot_ less work because the tokenizer functions of
            PHP can be used. I already started this and it looks doable. Will
            commit it when the code does not make my eyes bleed. The reason why 
            I want it so badly is that we can utilize all the existing PHP tests 
            by:
                * Compiling them to snow.
                * Compiling them back to PHP.
                * Seeing if the tests still passes.
            Which would be an awesome suite of tests for the Snow compiler. Lets 
            see how it goes.
            
        Dennis:
            If you think you can make it work, let's do it then!
            It gives access to a nice set of tests, but don't get your hopes
            up since we can't make use of the more advanced snow features.
            (or the php-snow compiler had to be _very_ advanced).
        
    What exacty is the use of '{ }' for object creation?
        Rune:
            This:
                my_object = {
                    'x': 32
                    'y':
                        z: 54
                        'm': 'foo'
                }
            would compile to:
                $my_object = new stdClass();
                $my_object->x = 32;
                $my_object->y->$z = 54;
                $my_object->y->m = 54;    
            Makes sense?    

        Dennis:
            I like it.
        
    Should 'const' keyword be 'con'?
        Rune:
            Maybe. I like the "three letter keyword" convention for "int, str,
            obj" etc. and "pri pub pro" but I am not sure how far we should take
            it. Am also not completely sold on "cls" instead of "class". Still
            partly undecided.
            
            What are our rules for naming keywords?
            
        Dennis:
            What is it that you object to on con/cls ?
            
        
    Should functions/methods be lowerCamelCased()? To make it distinct from
        vars_with_underscore.
        Rune:
            They are still not completely distinct because "foo" could be both a 
            function and a var which is also ok. The reason I chose the 
            underscore convention is that most of the PHP internal functions
            are named that way. I prefer the vars_with_underscore because it 
            looks very ruby-rockstar simple and readable but am ok with 
            lowerCamelCased() as well.
        Dennis:
            You are absolutely right, i was thinking more from a userland
            perspective.
        
    String interpolation and variable variables
        There's a conflict in the spec on lines 99-106
        I suppose that: string = "%foo()" injects the return of function foo
        into 'string'. Furthermore there's variable variables:
        foo = "bar"
        %foo() # invoke function bar
        This has to be reworked, when we expand this using the current syntax,
        what happens here:
        foo = "bar"
        baz = "%foo()" # injects the return of foo()?
        baz = "%%foo()" # injects the return of bar()?
        This seems like a major WTF to me.
        
        Rune:
            Your example:
                foo = "bar"
                baz = "abc %foo()" # inject the return of foo()!
                baz = "abc %%foo()" # inject the return of bar()!
            Would compile to:
                <?php
                $foo = 'bar';
                baz = 'abc' . foo();
                # Variable variables also looks weird in PHP I think.
                baz = 'abc' .  $foo();
                ?>
            I think it looks quite logical. How would you change it?
            
        Dennis:
            Well, I have thought about and I'm okay with that now, I was afraid
            it would be inconsistent but there's a visual distinction since
            parenthesis are required on a function call:
                fn bar: return "bar"
                foo = "bar"
                print "%foo" # print the contents of var foo
                print "%bar()" # print the return of bar()
                print "%%foo()" # print the return of bar()
    
    Multiple assignments
        Does this mean we can do swapping?
        a, b = b, a
        I think the comma can be removed here BTW.
        
        Rune:
            LOL again with the comma removal:
                a b = b a # Rather sexy.
            Swapping should be possible but not easy to parse. See comment in 
            the "Automatic variable naming" section.
        Dennis:
            Agree, we should focus on other things first.
        
    Magic 'args' array in functions/methods
        I like the idea, I also think we should make it read only.
        Rune: Agreed.

    Functions with inner functions
        Can you explain this to me? Also provide use case(s) please.

        Rune: 
            Again as PHP is mostly procedural functions often have helper
            functions that is and should only be used by that function. An 
            example is:
                function some_func($str) {
                    // Do stuff
                    _some_func_helper($str);
                    // Do other stuff;
                }
                
                function _some_func_helper($str) {
                    // Do stuff to $str
                    return $str;
                }
            I would like to collect the "_some_func_helper" function inside the
            "some_func" function so the Snow code would look like:
                @str str
                fn some_func
                    fn helper (@str str)
                        # Do stuff to str
                        return str
                    # Do stuff
                    helper(str)
                    # Do other stuff
            When compiling to PHP we can auto prefix inner functions with the 
            name of their outer functions.
            
        Dennis:
            Looks nice, but..
            * How do we resolve naming conflicts?
                fn _some_func: return "foo" # throw fatal? Would be weird IMO..
                fn some_func
                    fn helper: return "bar"
            * It gives me the impression i'm able to do something like this:
                fn some_func
                    fun helper: return "foo"
                    return helper
              I'm afraid we can't do that without the help of closures
              and thus targetting 5.3 specificly
                    
    Infix operator
        I don't really understand your 'Infix operator' chapter, line 280
        Rune:
            Just kind of an advanced userland keyword matcher that would call
            the corresponding infix function. Too advanced. Deleted for now.
            
    Scala-style infix-operator
        It doesn't look particularly readable or useful.
        Rune:
            No I didn't actually want you to see that - was just fooling around.
            Erased.
        
    @classvars
        I think this could be a powerful construct. I have been thinking
        about it and came with this:
            cls MyClass
                #some classvar
                pro int my_var
                
                #This method has 2 parameters:
                    my_var: This is a classvar, gets 'mapped' to the previously
                            defined property
                    my_int: regular parameter
                @classvar my_var
                @int my_int
                fn __construct
                    # do stuff
                
                #This results in an error, myothervar is not yet declared
                @classvar my_other_var
                fn somefunc
                    # do stuff
        
        Maybe we can even imply getter/setter generation, possibly controlled
        by annotations.
            pro int my_var #setMyVar() and getMyVar() are created, also used in
                            methods when @classvar annotation is used
                            Those methods can also be overriden
            @set
            pro int other_var # only setOtherVar() is created
            @get
            pro int other_var # only getOtherVar() is created
            @getset
            pro int other_var # this is the default setting, both getter and
                                setter are generated
        
        Maybe it's just a bit too magic, but i'm curious to know your take on this
        
        Rune:
            ## @classvar ##
            Thats just beautiful I love it! Will try it out with some of my
            classes and some from Zend framework.
            
            ## @get / @set ##
            I _really_ like @set and @get! I think multiple annotations 
            should be allowed on a single line: 
                @set @get # Because we hate commas?
                pro int other_var
            or 
                @set,@get
                pro int other_var
            or
                @set+@get
                pro int other_var
            that would eliminate the need for @getset as well.            
        Dennis:
            Great!
            You're right, if we allow @getset we should allow @setget as well
            I propose optional commas
            
# More musings #

    Postfix  '||'s
        eg: toBe || notToBe
        I can totally get in to this. But...
        It feels like this implies that there's also a postfix '&&'.
        When there is a postfix '&&', I would almost expect it to be the magic
        (and imaginary) 'atomic' operator. Formally defined: 
            'Evaluate operand1 and operand2, when one of them evaluates to false
             rollback to the state before either one of them was executed'
        Rune:
            Will need to see some examples before I fully understand what you
            just wrote :).
        Dennis:
            I'll try and elaborate more on this
        
             
    Array dereferencing
        I don't know whether this will be in PHP6 or not, but would be nice to have
        Example:
        first_element = funcThatReturnsArray()[0]
        
        Rune: 
            Yes definitely a nice to have, but uses "Automatic variable naming"
            which can make the generated code ugly very fast! It doesn't sound
            like the PHP core people want array dereferencing which on the other
            hand is a good reason why we should have it :).
        Dennis:
            Let's drop it for now then.
        
    Automatic variable naming
        There are places where we will need to make intermediate variables
        on the PHP side, with multiple assignments for example.
        We will need a naming scheme for that, while retaining a
        'non generated' look.
        
        Rune:
            Multiple assignments would only need "Automatic variable naming" if
            we allow variable swapping, right?
            
            I think we should only implement features where we can guarantie
            that the generated code looks perfect without needing to understand
            the corresponding Snow code.
            
        Dennis:
            When i wrote this I had more places in mind where we would need
            automatic variable naming, can't remember them now though...
            I agree we should only implement something like this if we can make
            it work 100% perfectly

# References #
    [1]: http://en.wikipedia.org/wiki/Method_chaining
    [2]: http://golang.org/doc/go_spec.html#Method_declarations
