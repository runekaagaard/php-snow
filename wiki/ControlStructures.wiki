#summary Description of the different control structures in Snow

<wiki:toc/>

= Conditionals =

== `if` ==
The `if` controlstructure follows the basic pattern of:
{{{
if <expr>
    statement
}}}

Where `<expr>` can be any statement that gets evaluated to a boolean. The codeblock `statement` gets executed when `<expr>` evaluates to `true`.

== `if` shorthand ==
`if` can also be abbreviated to the form:
{{{
if <expr>: statement
}}}
This way only one statement is allowed (no code block) and the `:` (colon) is mandatory.

== `elif` / `else` ==
_Elseif/else_ construct. Follows the form:
{{{
if <expr>
    statement
elif <expr2>
    statement2
else
    statement3
}}}

The elif-part can be infinitely repeated and gets evaluated only when `<expr>` evaluates to false.
The else block is the last resort, when no `if` or `elif` evaluates to true.

== `switch` ==
The `switch` statement is like a bunch `if`/`elif` statements. It's basic form is:
{{{
switch <expr>
    case 0
        statement
    case 1
        statement
    default
        statement
}}}
Note that a `break` statement is not necessary. It is the standard. In fact, the keyword is unsupported.
We now have the `fallthru` keyword, it's effect is exactly the opposite of `break`.

Instead of specifying where to stop evaluation of the following statements, you tell the parser explicitly to 'fall through' to the next `case`.

{{{
# Example #1:
a = 1
switch a
    case 0
        echo 0
    case 1
        echo 1
    case 2
        echo 2
# prints: 1
}}}
{{{
# Example #2:
a = 1
switch a
    case 0
        echo 0
        fallthru
    case 1
        echo 1
        fallthru
    case 2
        echo 2
        fallthru
# prints: 12
}}}

Switch can also be used with the [Putin putin] keyword.
{{{
# Example #3: Usage of the putin keyword
a = 2
switch a putin b = 2
    case 1
        += 1
    case 2
        += 2
    case 3
        += 3
# b == 4
}}}
{{{
# Example #4: return from a switch statement
a = 2
return switch putin dummy
    case 1
        += 1
    case 2
        += 2
        fallthru
    case 3
        += 3
# returns 5
}}}


= Loops =

== `for` ==
Good old (t)rusty `foreach` has left the building, welcome the new and improved `for`.

`for` has become a powerful construct and can take many forms.
We'll start with a basic example and work our way done to some more advanced stuff.
{{{
# Example #5:
a = [1 2 3]
for v in a
    echo v, "\n"
}}}
Pretty basic example. It iterates over all the elements in a and prints the value
{{{
# Example #6:
a = [1 2 3]
for k v in a
    echo k, ":", v, "\n
}}}
In this way it takes both the key and the value from the array, resulting in the output:
{{{
0: 1
1: 2
2: 3
}}}
And of course, the [Putin putin] keyword can be used:
{{{
# Example #7: Factorial implementation using putin keyword
fn factorial(int i)
    return for i to 2 step -1 putin a=i: *= i-1
# print fn(5) # prints: 120
}}}