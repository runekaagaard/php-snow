# Rune:
    About not using "class Foo" and "fn bar" it might get ambiguous. How do we
    know if
        foo
    means
        <?php $foo; ?>
    or
        <?php foo(); ?>
    ? It might be enough to simply use naming conventions and indention but I
    am not sure. But on the other hand the more I look at it, the more I like
    it. But I think I still prefer using the "class" and "fn" keywords because
    it adds to the readability. What are your thoughts on this?
#Dennis:
    Yeah, I already figured that. It was inspired by your Conventions chapter 
    in the snow spec. I think a lot/most of the cases can be disambiguated by
    analysis, but not all by far.
    I do think it's an interesting concept though and deserves further research.
    Besides that, when explicitly defining a class i'd prefer the keyword 
    'cls', following the '3 chars per keyword'-convention.

# Rune:
    Definitely it looks _very_ lean and mean without "cls" and "fn".

# Rune: Class because it starts with a capital letter?
#Dennis: Exactly, no ambiguity here
FTP
    #maybe constants can have default type int?
    # Rune:
        Think that is too magic but i like the way you define consts in the 
        class by naming convention. Looks cool.
    #Dennis: You could be right here. I was just thinking that possibly
        95% of the time, my constants are ints.
    int OPT_TRANS_ASCII = FTP_ASCII
    int OPT_TRANS_BINARY = FTP_BINARY
    int OPT_TRANS_AUTO = 3

    #access modifiers: 
    # Rune: Yes I like this!
    #Dennis: Great, I'll add it to the spec!
        pub: public (default)
        pro: protected
        pri: private
    
    # Rune: I like the omission of the "," separator.
    #Dennis: Me too, though counter intuitive, the comma is there before you
        even know it ;) I also love the array notation, makes it feel really
        lean and mean!
    pro arr ascii_types = ["text" "csv"]
    pro arr binary_types = ["jpg" "jpeg" "gif" "psd"]
    pro int default_transmode = OPT_TRANS_ASCII
    
    #connection resource
    pro res conn
	
    #i think classvars should be defined on the method level, as opposed to class level
    #not only the constructor should have the 'privilege' of defining classvars
    # Rune: 
        Hmm that is very interesting, it is allmost close to a getter/setter
        thing. I somehow like it but maybe the classvars get split up a bit too
        much and it gets harder to scan the class for its available vars.
    #Dennis:
        Exactly what I was thinking. I actually made a note about it at work
        today, don't have it here though..
        I _really_ like the idea behind it, but it may need some polishing.
    
    #constructs FTP object
        Wrapper on top of FTP protocol
        Enables file/directory listing, upload/download etc
    @classvar pro str host
        #the ftp host to connect to
        !%->empty
    @classvar pro int port=21
        #the port to connect (defaults to 21)
        %>0 && %<65536
    @classvar pro int timeout=30
        #connect timeout, bail out if exceeded
        #defaults to 30, 0 means wait forever
    __construct
        # Rune:
            I like the special use of "or". Maybe we should disable "AND", "OR",
            etc., and only allow "&&", "||", etc. That follows the "one way of
            doing things" philosophy and frees up "or" for other uses.
        #Dennis:
            No argument there.
        conn = ftp_connect(host port timeout) or throw Exception("Couldn't connect to host '%host%'")

    @str user
    @str pass
    login
        return ftp_login(conn user pass)
    
    @str local
    @str remote
    @int trans_mode
    put
        # Rune:
            Is this how it would compile to PHP:
                <?php
                if ($transMode != self::OPT_TRANS_AUTO) {
                    $this->getTransMode($local);
                }
                ?>
            ??? If it is, I like it.
        #Dennis: 
            Yeah, I think so.
            Regarding your 'unless vs if' comment, this is what it will look like:
            trans_mode = getTransMode(local) if trans_mode == OPT_TRANS_AUTO
            It's indeed more readable, none of that double negation stuff.
            Get's complicated really quickly I guess.
            The only thing i'm worried about is lexer/parser implementation. 
            Maybe we can use keyword 'when'? Or do you think it won't impose
            complications?
        # Rune:
            Just meant than when we compiled the "unless" sentence into a "if"
            sentence we would have to reverse the operators. Postfix "if" looks
            very sexy and dangerous. I like the "when" keyword a lot, better
            than "unless".
            
        trans_mode = getTransMode(local) unless trans_mode != OPT_TRANS_AUTO # perl style unless
        ftp_put(conn local remote trans_mode) or throw Exception("Couldn't get file '%remote'")
    
    @str local
    @str remote
    @int trans_mode
    get
        trans_mode = getTransMode(local) unless trans_mode != OPT_TRANS_AUTO
        ftp_get(conn local remote trans_mode) or throw Exception("Couldn't get file '%remote'")

    #checks whether a file exists on the remote side
    @str file
        #the filename to check for
        !%->empty
    fileExists
        # Rune: Nice use of method chaining :)
        #Dennis: looks nice doesn't it?
            It might even be possible to do this:
            return ftp_nlist(conn file->dirname)->in_array(file->basename)
            or:
            return conn->ftp_nlist(file->dirname)->in_array(file->basename)
            I'll elaborate more on this in a separate document
        list = ftp_nlist(conn file->dirname)
        return list->in_array(file->basename)
    
    #determine transfermode to use
    @str file
    getTransMode
        for ext in ascii_types
            return OPT_TRANS_ASCII unless file->substr(-ext->strlen) != ext
        for ext in binary_types
            return OPT_TRANS_BINARY unless file->substr(-ext->strlen) != ext
        return default_transmode
    
    close
        return ftp_close(conn)


try
    ftp = FTP("my.host")
    ftp.login("user" "pass")
    ftp.get("/remote/file" "/local/file")
@Exception e
catch: e->var_dump
