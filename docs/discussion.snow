# Discussion about spec #

    Loops and 'putin' keyword
        I don't really understand the concept.
        Could you provide me with some explanation and possibly one or more
        use cases?
        
        Rune:
            PHP being mostly a procedural language you constantly have to deal 
            with a lot of side effects which clutters the code and makes you 
            angry. I think we should definitely address anonomous functions as 
            well at some point but we should also optimize looping over arrays 
            and collecting data which is what "putin" tries to do. Consider this 
            very normal pattern in PHP:
                <?php
                function some_func($rows) {
                    # Could also be an array or an int.
                    $html = '<h1>Page title</h1>'; 
                    foreach ($rows as $row) {
                        $html .= "<h2>$row[title]</h2>";
                    }
                    return $html;
                ?>
                
                In Snow this could be:
                @array rows
                fn some_func
                    # Loop through rows and return the content of the "html" 
                    # variable when we are done. The "html" is initialized to 
                    # "<h1>Page title</h1>".
                    return for row in rows putin html='<h1>Page title</h1>'
                        # Inside a loop ".=" collects into the variable mentioned
                        # just after the "putin" keyword.
                        .= "<h2>%row['title']</h2>"
                    And LOC count has gone from 6 to 3.
                
                In snow.snow r2 I also suggested:
                    return for row in rows putin ''
                but then we would need to use "Automatic variable naming" as you
                call it and we should minimize that. Deleted from snow.snow.
                
                Does this clarify and what do you think?
            
    Method chaining
        What exactly is the difference between '.' and '->'
        Is it correct to state that:
            * '.' operates on objects. example:
                ftp = FTP("host")
                ftp.login("user" "pass")
            * '->' operates on native types. example:
                ["a" "b" 3: "c"]->print_r
        This is not what I define as method chaining. [1]
        It looks more like go's receiver methods. [2]
        But this is what I understand from the spec.
        What's your take on this?

        Rune:
            You you are absolutely right "method chaining" is a completely bad 
            name for it because "everything is an object" does not apply to PHP 
            which is more like "everything is a ZVAL - use a function to 
            manipulate it". Since I think Snow should be a mostly dynamically 
            typed language there is not so much we can do to change that. What I
            basically means with the "->" keyword is that it is a reverse 
            function call where the value passed to function comes before the 
            function name not after. Examples:
                Snow: 5->foo
                PHP: foo(5);
                Snow: somefunc()->foo->bar
                PHP: bar(foo(somefunc())));
                Snow: "i am white"->strtoupper
                PHP: strtoupper("i am white");
            
            Do you like it and what should we call it?

    Use of quotation
        Will PHP's default quotation rules be applied? I think we should.
        foo = ^("bar" 'baz' "%bar" '%baz')
        Gets translated to:
        <?php $foo = "bar" . 'baz' . "$bar" . '$baz'; ?>
        I think that looks fair.
        
        Rune:
            I concur!
        
    Escaping
        Default backslash escape?
        
        Rune:
            Yes.
        
    HAML
        Hadn't heard of it before, but it looks nice indeed.
        But doesn't it impose problems with the %-notation? Or is that the 
        reason you put a '$' before the variable's name?
        
        Rune:
            No the "$" is a mistake. I consider the HAML block a double quoted
            string thats why I use the "%". Indentation is used to decide where
            it ends, i.e. "next line with the same or less indentation as the
            beginning line". It could do with some more documentation - will try
            to write that. Is probably rather complicated to code.
    
    Compatible with all existing PHP code
        Could you define this more clearly?
        Does it mean the snow compiler creates code compatible with PHP 3 for
        example? I don't think it should.
        
        Rune: Lol no no. I just mean that we should be able to call functions,
        methods and constants not complying with the naming conventions of Snow
        so we are compatible with existing non-snow PHP code.
        
    Can compile existing code to snow
        Though this would be a nice feature, is it worth the hassle?
        Is the benefit large enough to justify amount of work?
        
        Rune:
            Well it is a _lot_ less work because the tokenizer functions of
            PHP can be used. I already started this and it looks doable. Will
            commit it when the code does not make my eyes bleed. The reason why 
            I want it so badly is that we can utilize all the existing PHP tests 
            by:
                * Compiling them to snow.
                * Compiling them back to PHP.
                * Seeing if the tests still passes.
            Which would be an awesome suite of tests for the Snow compiler. Lets 
            see how it goes.
        
    What exacty is the use of '{ }' for object creation?
        Rune:
            This:
                my_object = {
                    'x': 32
                    'y':
                        z: 54
                        'm': 'foo'
                }
            would compile to:
                $my_object = new stdClass();
                $my_object->x = 32;
                $my_object->y->$z = 54;
                $my_object->y->m = 54;    
            Makes sense?    
        
    Should 'const' keyword be 'con'?
        Rune:
            Maybe. I like the "three letter keyword" convention for "int, str,
            obj" etc. and "pri pub pro" but I am not sure how far we should take
            it. Am also not completely sold on "cls" instead of "class". Still
            partly undecided.
            
            What are our rules for naming keywords?
        
    Should functions/methods be lowerCamelCased()? To make it distinct from
        vars_with_underscore.
        Rune:
            They are still not completely distinct because "foo" could be both a 
            function and a var which is also ok. The reason I chose the 
            underscore convention is that most of the PHP internal functions
            are named that way. I prefer the vars_with_underscore because it 
            looks very ruby-rockstar simple and readable but am ok with 
            lowerCamelCased() as well.
        
    String interpolation and variable variables
        There's a conflict in the spec on lines 99-106
        I suppose that: string = "%foo()" injects the return of function foo
        into 'string'. Furthermore there's variable variables:
        foo = "bar"
        %foo() # invoke function bar
        This has to be reworked, when we expand this using the current syntax,
        what happens here:
        foo = "bar"
        baz = "%foo()" # injects the return of foo()?
        baz = "%%foo()" # injects the return of bar()?
        This seems like a major WTF to me.
        
        Rune:
            Your example:
                foo = "bar"
                baz = "abc %foo()" # inject the return of foo()!
                baz = "abc %%foo()" # inject the return of bar()!
            Would compile to:
                <?php
                $foo = 'bar';
                baz = 'abc' . foo();
                # Variable variables also looks weird in PHP I think.
                baz = 'abc' .  $foo();
                ?>
            I think it looks quite logical. How would you change it?
    
    Multiple assignments
        Does this mean we can do swapping?
        a, b = b, a
        I think the comma can be removed here BTW.
        
        Rune:
            LOL again with the comma removal:
                a b = b a # Rather sexy.
            Swapping should be possible but not easy to parse. See comment in 
            the "Automatic variable naming" section.
        
    Magic 'args' array in functions/methods
        I like the idea, I also think we should make it read only.
        Rune: Agreed.

    Functions with inner functions
        Can you explain this to me? Also provide use case(s) please.

        Rune: 
            Again as PHP is mostly procedural functions often have helper
            functions that is and should only be used by that function. An 
            example is:
                function some_func($str) {
                    // Do stuff
                    _some_func_helper($str);
                    // Do other stuff;
                }
                
                function _some_func_helper($str) {
                    // Do stuff to $str
                    return $str;
                }
            I would like to collect the "_some_func_helper" function inside the
            "some_func" function so the Snow code would look like:
                @str str
                fn some_func
                    fn helper (@str str)
                        # Do stuff to str
                        return str
                    # Do stuff
                    helper(str)
                    # Do other stuff
            When compiling to PHP we can auto prefix inner functions with the 
            name of their outer functions.
                    
    Infix operator
        I don't really understand your 'Infix operator' chapter, line 280
        Rune:
            Just kind of an advanced userland keyword matcher that would call
            the corresponding infix function. Too advanced. Deleted for now.
            
    Scala-style infix-operator
        It doesn't look particularly readable or useful.
        Rune:
            No I didn't actually want you to see that - was just fooling around.
            Erased.
        
    @classvars
        I think this could be a powerful construct. I have been thinking
        about it and came with this:
            cls MyClass
                #some classvar
                pro int my_var
                
                #This method has 2 parameters:
                    my_var: This is a classvar, gets 'mapped' to the previously
                            defined property
                    my_int: regular parameter
                @classvar my_var
                @int my_int
                fn __construct
                    # do stuff
                
                #This results in an error, myothervar is not yet declared
                @classvar my_other_var
                fn somefunc
                    # do stuff
        
        Maybe we can even imply getter/setter generation, possibly controlled
        by annotations.
            pro int my_var #setMyVar() and getMyVar() are created, also used in
                            methods when @classvar annotation is used
                            Those methods can also be overriden
            @set
            pro int other_var # only setOtherVar() is created
            @get
            pro int other_var # only getOtherVar() is created
            @getset
            pro int other_var # this is the default setting, both getter and
                                setter are generated
        
        Maybe it's just a bit too magic, but i'm curious to know your take on this
        
        Rune:
            ## @classvar ##
            Thats just beautiful I love it! Will try it out with some of my
            classes and some from Zend framework.
            
            ## @get / @set ##
            I _really_ like @set and @get! I think multiple annotations 
            should be allowed on a single line: 
                @set @get # Because we hate commas?
                pro int other_var
            or 
                @set,@get
                pro int other_var
            or
                @set+@get
                pro int other_var
            that would eliminate the need for @getset as well.            
            
# More musings #

    Postfix  '||'s
        eg: toBe || notToBe
        I can totally get in to this. But...
        It feels like this implies that there's also a postfix '&&'.
        When there is a postfix '&&', I would almost expect it to be the magic
        (and imaginary) 'atomic' operator. Formally defined: 
            'Evaluate operand1 and operand2, when one of them evaluates to false
             rollback to the state before either one of them was executed'
        Rune:
            Will need to see some examples before I fully understand what you
            just wrote :).
        
             
    Array dereferencing
        I don't know whether this will be in PHP6 or not, but would be nice to have
        Example:
        first_element = funcThatReturnsArray()[0]
        
        Rune: 
            Yes definitely a nice to have, but uses "Automatic variable naming"
            which can make the generated code ugly very fast! It doesn't sound
            like the PHP core people want array dereferencing which on the other
            hand is a good reason why we should have it :).
        
    Automatic variable naming
        There are places where we will need to make intermediate variables
        on the PHP side, with multiple assignments for example.
        We will need a naming scheme for that, while retaining a
        'non generated' look.
        
        Rune:
            Multiple assignments would only need "Automatic variable naming" if
            we allow variable swapping, right?
            
            I think we should only implement features where we can guarantie
            that the generated code looks perfect without needing to understand
            the corresponding Snow code.

# References #
    [1]: http://en.wikipedia.org/wiki/Method_chaining
    [2]: http://golang.org/doc/go_spec.html#Method_declarations
